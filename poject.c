#pragma config(Sensor, S1,     TouchSensor,    sensorTouch)
#pragma config(Sensor, S2,     SonarSensorRight, sensorSONAR)
#pragma config(Sensor, S3,     SonarSensorLeft, sensorSONAR)
#pragma config(Sensor, S4,     LightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void left (void);
void right (void);
void turnaround (void);
void forwardfull (void);
void forwardsmall (void);
void backwardsmall (void);
void findingleft (void);
void findingright (void);
void scan (void);
void backhome (void);
void orientation (void);

int x = 0;
int y = 0;
int find = 0;
int direction = 1;
/*
1 = north
2 = east
3 = south
4 = west
*/

int forwardCounter = 0;
int tempforcounter = 0;

int tepmleft;
int minleft;
int tempright;
int minrght;

task main()
{
		nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
		nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
		int countValue = 0;												//look if there is black cell
		int lineCounter = 0;											//counts lines
		int lightValue = 0;												//light value
		int darkValue = 0;												//dark value
		int thresholdValue = 0;
		int finish = 0;														//when 5 prgram stops
		int turns = 0;

	/**************************************************************************************/
		/*while(SensorValue(TouchSensor) == 0)
		{
		}

		lightValue = SensorValue(LightSensor);

		while(SensorValue(TouchSensor) == 0)
		{
		}

		darkValue = SensorValue(LightSensor);*/

		thresholdValue = 50;

		while(SensorValue(TouchSensor) == 0)
		{
		}
	/********************************************************************************************/

		while(finish !=2)
		{
			if(forwardCounter == 8)
			{
				turnaround();
				tempforcounter = 1;
			}

			if(forwardCounter == 0 && tempforcounter == 1)
			{
				turnaround();
			}

			if(forwardCounter == 8 && tempforcounter == 1)
			{
				turnaround();
			}

			//scan ();

			if (find == 2)
			{
				backhome ();
				finish = 2;
			}
			else
            {
                   if(x == 0 && y == 0)
                {
                    forwardsmall ();
                }

                if(SensorValue(LightSensor) < thresholdValue)
                {
                    backwardsmall();

                    if(turns == 0)
                    {
                        right();
                        forwardfull();
                        left();
                        turns++;
                    }
                    else
                    {
                        left();
                        forwardfull();
                        right();
                        turns--;
                    }

                    forwardsmall();
                }
                else
                {
                    forwardfull ();
                }

                if(SensorValue(TouchSensor) != 0 )
                {
                    find++;
                }
			}




		}
}// end main

void orientation (void)
{
	if(direction == 1)
	{
		y++;
	}
	else
	{
		if(direction == 2)
		{
			x++;
		}
		else
		{
			if(direction == 3)
			{
				y--;
			}
			else
			{
				x--;
			}
		}
	}
}

void left (void)
{
	motor[motorA] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = 185;
	nMotorEncoderTarget[motorC] = -185;
	motor[motorA] = 20;
	motor[motorC] = -20;


	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	if(direction == 1)
	{
		direction = 4;
	}
	else
	{
		direction--;
	}

	motor[motorA] = 0;
	motor[motorC] = 0;
}


void right (void)
{
	motor[motorA] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = 185;
	nMotorEncoderTarget[motorC] = -185;
	motor[motorA] = -20;
	motor[motorC] = 20;


	while (nMotorRunState[motorA] != runStateIdle)
	{
			// idle loop
	}

	if(direction == 4)
	{
		direction = 1;
	}
	else
	{
		direction++;
	}

	motor[motorA] = 0;
	motor[motorC] = 0;
}

void turnaround(void)
{
	right ();
	right ();
}



void forwardfull (void)
{
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

	motor[motorA] = 0;
	motor[motorC] = 0;

	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = 280;
	nMotorEncoderTarget[motorC] = 280;

	motor[motorA] = 40;
	motor[motorC] = 40;

	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	orientation();

	if(direction == 1)
    {
        forwardCounter++;
    }
    if(direction == 3)
    {
        forwardCounter--;
    }

	motor[motorA] = 0;
	motor[motorC] = 0;
}

void forwardsmall (void)
{
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	motor[motorA] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = 80;
	nMotorEncoderTarget[motorC] = 80;
	motor[motorA] = 20;
	motor[motorC] = 20;

	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	motor[motorA] = 0;
	motor[motorC] = 0;
}

void backwardsmall (void)
{
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	motor[motorA] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = -80;
	nMotorEncoderTarget[motorC] = -80;
	motor[motorA] = -20;
	motor[motorC] = -20;

	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	motor[motorA] = 0;
	motor[motorC] = 0;
}
//remember to count x and y
void findingleft (void)
{
	left ();
	if (x == 0 && y == 0)
	{
		forwardfull ();
		if (SensorValue(touchSensor) != 0)
		{
			find++;
			turnaround ();
			forwardfull ();
			left ();
		}
		else
		{
		right ();
		forwardfull ();
		left ();
		forwardfull ();
		forwardfull ();
		left ();
		forwardfull ();
		if(sensorValue(touchSensor) != 0)
		{
			find++;
		}
		turnaround ();
		forwardfull ();
		right ();
		forwardfull ();
		forwardfull ();
		right ();
		forwardfull ();
		left ();
		forwardfull ();
		left ();
		}
	}

	if (x == 1 && y == 3)
	{
		turnaround ();
		forwardfull ();
		right();
		forwardfull ();
		forwardfull ();
		right();
		forwardfull ();
		if(sensorValue(touchSensor) != 0)
		{//found and go back to line
			find++;
			turnaround ();
			forwardfull ();
			left ();
			forwardfull ();
			forwardfull ();
			left ();
			forwardfull ();
		}
		else
		{
			left ();
			forwardfull ();
			if(sensorValue(touchSensor) != 0)
			{
				find++;
				turnaround ();
				forwardfull ();
				right ();
				forwardfull ();
				left ();
				forwardfull ();
				forwardfull ();
				left ();
				forwardfull ();
			}
			else
			{
				forwardfull ();
				if(sensorValue(touchSensor) != 0)
				{
					find++;
				}
				turnaround ();
				forwardfull ();
				forwardfull ();
				right ();
				forwardfull ();
				left ();
				forwardfull ();
				forwardfull ();
				left ();
				forwardfull ();
			}

		}
	}
	// finish it
	if (x == 1 && y == 4)
	{
        forwardfull();
        left();
        forwardfull();
        forwardfull();
        left();
        forwardfull();
        if(sensorValue(touchSensor) != 0)
        {
            find++;
            turnaround();
            forwardfull();
            right();
            forwardfull();
            forwardfull();
            right();
            forwardfull();
            turnaround();
        }
        else
        {
            right();
            forwardfull();
            if(sensorValue(touchSensor) != 0)
            {
                find++;
                turnaround();
                forwardfull();
                left();
                forwardfull();
                right();
                forwardfull();
                forwardfull();
                right();
                forwardfull();
                turnaround();
            }
            else
            {
                forwardfull();
                if(sensorValue(touchSensor) != 0)
                {
                    find++;
                }
                turnaround();
                forwardfull();
                forwardfull();
                left();
                forwardfull();
                right();
                forwardfull();
                forwardfull();
                right();
                forwardfull();
                turnaround();
            }
        }
	}

	if(x == 0 && y == 6)
	{
        turnaround();
        forwardfull();
        right();
        forwardfull();
        forwardfull();
        forwardfull();
        right();
        forwardfull();
        if(sensorValue(touchSensor) != 0)
        {
            find++;
        }
        turnaround();
        forwardfull();
        left();
        forwardfull();
        forwardfull();
        forwardfull();
        left();
        forwardfull();
	}

	if (x == 0 && y == 7)
	{
        left();
        forwardfull();
        if(sensorValue(touchSensor) != 0)
        {
            find++;
            turnaround();
            left();
        }
        else
        {
           turnaround();
            forwardfull();
            right();
            forwardfull();
            forwardfull();
            right();
            forwardfull();
            forwardfull();
            forwardfull();
            right();
            forwardfull();
            forwardfull();
            if(sensorValue(touchSensor) != 0)
            {
                find++;
            }
            turnaround();
            forwardfull();
            forwardfull();
            left();
            forwardfull();
            forwardfull();
            forwardfull();
            left();
            forwardfull();
            forwardfull();
        }
	}

}

void findingright (void)
{
	if (x == 0 && y == 1)
	{

	}

	if(x == 0 && y == 6)
	{

	}
}

void scan (void)
{
	//finding object on left
	if(SensorValue(SonarSensorLeft) < 255)
	{
		findingleft ();
	}

	//finding object on right
	if(SensorValue(SonarSensorRight) < 255)
	{
		findingright ();
	}
}

void backhome (void)
{
	turnaround();
	turnaround();
}
