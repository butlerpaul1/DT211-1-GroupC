#pragma config(Sensor, S1,     TouchSensor,    sensorTouch)
#pragma config(Sensor, S2,     SonarSensorRight, sensorSONAR)
#pragma config(Sensor, S3,     SonarSensorLeft, sensorSONAR)
#pragma config(Sensor, S4,     LightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


//declaring functions

void left (void); 	//functoin for turning left
void right (void); 	//function for turnint right
void turnaround (void);	//function for turning 180 degrees
void forwardfull (void); 	//moving robot from centre of one cell to other
void forwardsmall (void);	//move robot from centre of cell to edge of cell (checking for black cells)
void backwardsmall (void);	//move robot from edge of cell to centre of cell (provide proper turning)
void findingleft (void); //function for left sensor
void findingright (void); //function for right sensor
void scan (void);	//scans for object
void backhome (void); //this function return robot to start position
void orientation (void); //updating position of robot

//global variables

int x = 0;  //value for recording position
int y = 0;	//value for recording position
int find = 0; //increment when find object
int direction = 1; //for navigating grid
/*
1 = north
2 = east
3 = south
4 = west
*/

int forwardCounter = 0; // counts lines and prevent from escaping from map

int thresholdValue = 0; //Used for light sensor

task main()
{
		nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
		nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
		int finish = 0;														//when 2 program stops
		int turns = 0;	//In avoiding black cells if 0 turns right if 1 turns left


		thresholdValue = 50; //Couldnt calculate value so we used 50

		while(SensorValue(TouchSensor) == 0)
		{
		}


		wait1Msec(100);
		//waiting for two bumps to start program


		while(SensorValue(TouchSensor) == 0)
		{
		}
	/********************************************************************************************/
	//Start of main program

	//loop which stops when robot back home
		while(finish !=2)
		{

		//after getting edge of map, robot scan for last element and back to start position
		if(forwardCounter == 8)
			{
				scan();
				turnaround();
				find = 2;
			}

			//clearing display and shows y, x, direction and crossed lines forward
			eraseDisplay();
			nxtDisplayBigStringAt(0, 31, "%d,%d,%d,%d" ,y,x,direction,forwardCounter);

			//scanning for objects
			if(forwardCounter != 8)
			{
			scan();
			}

			//if robot found 2 objects or reached end of map backs start position and finish program
			if (find == 2)
			{
				backhome ();
				finish = 2;
			}
			else//if not move forward avoiding black cells
            {
                   if(x == 0 && y == 0)
                {
                    forwardsmall ();
                }
								//avoiding black cells
                if(SensorValue(LightSensor) < thresholdValue)
                {
                    backwardsmall();

                    if(turns == 0)
                    {
                        right();
                        forwardfull();
                        left();
                        turns++;
                    }
                    else
                    {
                        left();
                        forwardfull();
                        right();
                        turns--;
                    }

                    forwardsmall();
                }
                else
                {
                	//moving forward by functions
                    forwardfull ();
                }

                if(SensorValue(TouchSensor) != 0 )
                {
                	//if object was on robots way beep and add find to memory
                    find++;
                    PlaySound(soundBeepBeep);
                }

                //erase display and shows values as before
                eraseDisplay();
				nxtDisplayBigStringAt(0, 31, "%d,%d,%d,%d" ,y,x,direction,forwardCounter);
			}//end else
		}//end else
}// end main

//orientation fuction

/*
this fuction updates position of robot
*/
void orientation (void)
{
	if(direction == 1)
	{
		y++;
	}
	if(direction == 2)
	{
		x++;
	}
	if(direction == 3)
	{
		y--;
	}
	if(direction == 4)
	{
		x--;
	}
}

//left function
/*
this fuction turns robot left and update direction of robot
*/
void left (void)
{
	motor[motorA] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = 180;
	nMotorEncoderTarget[motorC] = -180;
	motor[motorA] = 20;
	motor[motorC] = -20;


	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	//updating direction of robot
	if(direction == 1)
	{
		direction = 4;
	}
	else
	{
		direction--;
	}

	motor[motorA] = 0;
	motor[motorC] = 0;
}

//right function
/*
this fuction turns robot right and update direction of robot
*/
void right (void)
{
	motor[motorA] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = 180;
	nMotorEncoderTarget[motorC] = -180;
	motor[motorA] = -20;
	motor[motorC] = 20;


	while (nMotorRunState[motorA] != runStateIdle)
	{
			// idle loop
	}

	//direction update
	if(direction == 4)
	{
		direction = 1;
	}
	else
	{
		direction++;
	}

	motor[motorA] = 0;
	motor[motorC] = 0;
}

//turn around function
/*
this fuction turns robot around in 180 degrees
*/
void turnaround(void)
{
	right ();
	right ();
}


//forwardfull function
/*
		moves robot exactly to same position of next cell
*/
void forwardfull (void)
{
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

	motor[motorA] = 0;
	motor[motorC] = 0;

	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = 290;
	nMotorEncoderTarget[motorC] = 290;

	motor[motorA] = 20;
	motor[motorC] = 20;

	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	//updating position
	orientation();

	//counts lines to edge of map
	if(direction == 1)
    {
        forwardCounter++;
    }
    if(direction == 3)
    {
        forwardCounter--;
    }

	motor[motorA] = 0;
	motor[motorC] = 0;
}

//forward small
/*
		moves robot from centre of cell to edge
*/
void forwardsmall (void)
{
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	motor[motorA] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = 75;
	nMotorEncoderTarget[motorC] = 75;
	motor[motorA] = 20;
	motor[motorC] = 20;

	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	motor[motorA] = 0;
	motor[motorC] = 0;
}

//backwardsmall function
/*
		moves robot from edge of cell to centre of cell
*/
void backwardsmall (void)
{
	nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	motor[motorA] = 0;
	motor[motorC] = 0;
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorA] = -75;
	nMotorEncoderTarget[motorC] = -75;
	motor[motorA] = -20;
	motor[motorC] = -20;

	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	motor[motorA] = 0;
	motor[motorC] = 0;
}

//findinleft function
/*
		function for left sensor which moves robot to object and back on previous position
*/
void findingleft (void)
{
	int counter = 0;
	int touch = 0;

	if (y == 1|| y == 2 || y == 5 || y == 8)
	{
		left();
		forwardsmall();
		touch = SensorValue(TouchSensor);
		while(touch == 0)
		{
			forwardfull();
			counter++;
			touch = SensorValue(TouchSensor);
			if(touch != 0)
			{
				find++;
				PlaySound(soundBeepBeep);
			}
			if(SensorValue(LightSensor) < thresholdValue)
			{
				touch = 1;
			}

			if(counter == 3)
			{
				touch = 1;
			}

			if(touch != 0)
			{
				backwardsmall();
				turnaround();
				while(counter != 0)
				{
					counter--;
					forwardfull();
				}
				left();
			}

		 }
	}


	if (x == 0 && y == 0)
	{
		forwardsmall();
		left();
		forwardfull ();
		if (SensorValue(TouchSensor) != 0)
		{
			find++;
			PlaySound(soundBeepBeep);
			turnaround ();
			forwardfull ();
			left ();
		}
		else
		{
		right ();
		forwardfull ();
		left ();
		forwardfull ();
		forwardfull ();
		left ();
		forwardfull ();
		if(SensorValue(TouchSensor) != 0)
		{
			find++;
			PlaySound(soundBeepBeep);
		}
		turnaround ();
		forwardfull ();
		right ();
		forwardfull ();
		forwardfull ();
		right ();
		forwardfull ();
		left ();
		forwardfull ();
		left ();
		}
		backwardsmall();
	}

	if (x == 1 && y == 3)
	{
		turnaround ();
		forwardfull ();
		right();
		forwardfull ();
		forwardfull ();
		right();
		forwardfull ();
		if(SensorValue(TouchSensor) != 0)
		{//found and go back to line
			find++;
			PlaySound(soundBeepBeep);
			turnaround ();
			forwardfull ();
			left ();
			forwardfull ();
			forwardfull ();
			left ();
			forwardfull ();
		}
		else
		{
			left ();
			forwardfull ();
			if(SensorValue(TouchSensor) != 0)
			{
				find++;
				PlaySound(soundBeepBeep);
				turnaround ();
				forwardfull ();
				right ();
				forwardfull ();
				left ();
				forwardfull ();
				forwardfull ();
				left ();
				forwardfull ();
			}
			else
			{
				forwardfull ();
				if(SensorValue(TouchSensor) != 0)
				{
					find++;
					PlaySound(soundBeepBeep);
				}
				turnaround ();
				forwardfull ();
				forwardfull ();
				right ();
				forwardfull ();
				left ();
				forwardfull ();
				forwardfull ();
				left ();
				forwardfull ();
			}

		}
	}
	if (x == 1 && y == 4)
	{
        forwardfull();
        left();
        forwardfull();
        forwardfull();
        left();
        forwardfull();
        if(SensorValue(TouchSensor) != 0)
        {
            find++;
            PlaySound(soundBeepBeep);
            turnaround();
            forwardfull();
            right();
            forwardfull();
            forwardfull();
            right();
            forwardfull();
            turnaround();
        }
        else
        {
            right();
            forwardfull();
            if(SensorValue(TouchSensor) != 0)
            {
                find++;
                PlaySound(soundBeepBeep);
                turnaround();
                forwardfull();
                left();
                forwardfull();
                right();
                forwardfull();
                forwardfull();
                right();
                forwardfull();
                turnaround();
            }
            else
            {
                forwardfull();
                if(SensorValue(TouchSensor) != 0)
                {
                    find++;
                    PlaySound(soundBeepBeep);
                }
                turnaround();
                forwardfull();
                forwardfull();
                left();
                forwardfull();
                right();
                forwardfull();
                forwardfull();
                right();
                forwardfull();
                turnaround();
            }
        }
	}

	if(x == 0 && y == 6)
	{
        turnaround();
        forwardfull();
        right();
        forwardfull();
        forwardfull();
        forwardfull();
        right();
        forwardfull();
        if(SensorValue(TouchSensor) != 0)
        {
            find++;
            PlaySound(soundBeepBeep);
        }
        turnaround();
        forwardfull();
        left();
        forwardfull();
        forwardfull();
        forwardfull();
        left();
        forwardfull();
	}

	if (x == 0 && y == 7)
	{
        left();
        forwardfull();
        if(SensorValue(TouchSensor) != 0)
        {
            find++;
            PlaySound(soundBeepBeep);
            turnaround();
            left();
        }
        else
        {
           turnaround();
            forwardfull();
            right();
            forwardfull();
            forwardfull();
            right();
            forwardfull();
            forwardfull();
            forwardfull();
            right();
            forwardfull();
            forwardfull();
            if(SensorValue(TouchSensor) != 0)
            {
                find++;
                PlaySound(soundBeepBeep);
            }
            turnaround();
            forwardfull();
            forwardfull();
            left();
            forwardfull();
            forwardfull();
            forwardfull();
            left();
            forwardfull();
            forwardfull();
        }
	}
}

//findinright function
/*
		function for right sensor which moves robot to object and back on previous position
*/
void findingright (void)
{

	int counter = 0;
	int touch = 0;

	if (y == 0|| y == 2 || y == 3 || y == 4 || y == 5 || y == 7 || y == 8)
	{
		right();
		forwardsmall();
		touch = SensorValue(TouchSensor);
		while(touch == 0)
		{
			forwardfull();
			counter++;
			touch = SensorValue(TouchSensor);
			if(touch != 0)
			{
				find++;
				PlaySound(soundBeepBeep);
			}
			if(SensorValue(LightSensor) < thresholdValue)
			{
				touch = 1;
			}

			if(counter == 3)
			{
				touch = 1;
			}


			if(touch != 0)
			{
				backwardsmall();
				turnaround();
				while(counter != 0)
				{
					counter--;
					forwardfull();
				}
				right();
			}

		 }
	}

	if (x == 0 && y == 1)
	{
		right();
		forwardfull();
		if(SensorValue(TouchSensor) != 0)
		{
			find++;
			PlaySound(soundBeepBeep);
			turnaround();
			forwardfull();
			right();
		}
		else
		{
			left();
			forwardfull();
			right();
			forwardfull();
			forwardfull();
			right();
			forwardfull();
			if(SensorValue(TouchSensor) != 0)
			{
				find++;
				PlaySound(soundBeepBeep);
			}
			turnaround();
			forwardfull();
			left();
			forwardfull();
			forwardfull();
			left();
			forwardfull();
			right();
			forwardfull();
			right();
		}
	}

	if(x == 0 && y == 6)
	{
		turnaround();
		forwardfull();
		left();
		forwardfull();
		forwardfull();
		left();
		forwardfull();
		if(SensorValue(TouchSensor) != 0)
		{
			find++;
			PlaySound(soundBeepBeep);
			turnaround();
			forwardfull();
			right();
			forwardfull();
			forwardfull();
			right();
			forwardfull();
		}
		else
		{
			right();
			forwardfull();
			if(SensorValue(TouchSensor) != 0)
			{
				find++;
				PlaySound(soundBeepBeep);
			}
			turnaround();
			forwardfull();
			left();
			forwardfull();
			right();
			forwardfull();
			forwardfull();
			right();
			forwardfull();
		}
	}
}
//scan function
/*
		Function which scan for object and run proper function
*/
void scan (void)
{


	//finding object on left
	if(SensorValue(SonarSensorLeft) < 255)
	{
		backwardsmall();
		findingleft ();
		forwardsmall();
	}

	//finding object on right
	if(SensorValue(SonarSensorRight) < 255)
	{
		backwardsmall();
		findingright ();
		forwardsmall();
	}
}

//backhome function
/*
		this function move our robot to start position
*/
void backhome (void)
{
	if(x==0)
	{
		while(direction!=3)
			{
				left();
			}
			while(y!=0)
			{
				forwardfull();
			}
	}
	else
	{
		if(x>0)
		{
			while(direction!=4)
			{
				left();
			}
			while(x!=0)
			{
				forwardfull();
			}
			while(direction!=3)
			{
				left();
			}
			while(y!=0)
			{
				forwardfull();
			}
		}
		else
		{
			while(direction!=2)
			{
				right();
			}
			while(x!=0)
			{
				forwardfull();
			}
			while(direction!=3)
			{
				right();
			}
			while(y!=0)
			{
				forwardfull();
			}
		}
	}
}
