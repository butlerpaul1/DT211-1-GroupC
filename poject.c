#pragma config(Sensor, S1,     TouchSensor,    sensorTouch)
#pragma config(Sensor, S2,     SonarSensorRight, sensorSONAR)
#pragma config(Sensor, S3,     SonarSensorLeft, sensorSONAR)
#pragma config(Sensor, S4,     LightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void left (void);
void right (void);

task main()
{
		nMotorPIDSpeedCtrl[motorA] = mtrSpeedReg;
		nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
			
	int countValue = 0;
	int lightValue = 0;
	int darkValue = 0;
	int sumValue = 0;
	int forwardLines = 7;
	
	
		while( countValue < 2)//forward
		{

			motor[motorA] = 30;
			motor[motorC] = 30;

        //when surface is black count goes up
			if( SensorValue(LightSensor) < 50)
			{
					countValue++;
					wait1Msec(100);
					
					//Waiting to exit black
			}//end if
			if (SensorValue(LightSensor) > 50)
			{
				countValue=0;
			}

			nxtDisplayBigStringAt(0, 31, "%d" ,countValue);

		}//end while

}// end main

void left (void)
{
		motor[motorA] = 0;
	motor[motorC] = 0;
	
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;

	nMotorEncoderTarget[motorA] = 185;
	nMotorEncoderTarget[motorC] = -185;

	motor[motorA] = 20;
	motor[motorC] = -20;

	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	motor[motorA] = 0;
	motor[motorC] = 0;

}

void right (void)
{
		motor[motorA] = 0;
	motor[motorC] = 0;
	
	nMotorEncoder[motorA] = 0;//reset
	nMotorEncoder[motorC] = 0;

	nMotorEncoderTarget[motorA] = 185;
	nMotorEncoderTarget[motorC] = -185;

	motor[motorA] = -20;
	motor[motorC] = 20;

	while (nMotorRunState[motorA] != runStateIdle)
	{
		// idle loop
	}

	motor[motorA] = 0;
	motor[motorC] = 0;

}
